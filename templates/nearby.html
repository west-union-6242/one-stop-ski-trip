<html>
    <head>
        <meta charset="utf-8">
		<title>United States Ski Resort Visualization</title>
        <style type="text/css">
            #gmap {
                height: 500px;
                width: 960px;
            }
		</style>
		<script type="text/javascript" src="public/d3.v5.min.js"></script>
        <script type="text/javascript" src="public/topojson.v2.min.js"></script>
        <script type="text/javascript" src="public/d3-geo-projection.v2.min.js"></script>
        <script type="text/javascript" src="public/d3-legend.min.js"></script>
		<script type="text/javascript" src="public/d3-tip.min.js"></script>
        <script type="text/javascript" src="public/topojson.v2.min.js"></script>

        <script>
            var gMap;
            var resortMarkers = []
            var lodgingMarkers = []

            markerColors = {
                'blue': 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png',
                'green': 'http://maps.google.com/mapfiles/ms/icons/green-dot.png'
            }

            function addGMapMarker(pos, markerArr, color=null) {
                const marker = new google.maps.Marker({
                    position: pos,
                    map: gMap
                });

                if(color && color in markerColors) {
                    marker.setIcon(markerColors[color])
                }
                markerArr.push(marker)
            }

            function addAllGmapMarkers(data, markerArr, color=null) {
                data.forEach(d => {
                    addGMapMarker(new google.maps.LatLng(d.lat, d.lon), markerArr, color)
                })
            }

            // Deletes all markers in the array by removing references to them.
            function deleteMarkers(markerArr) {
                for (let i = 0; i < markerArr.length; i++) {
                    markerArr[i].setMap(null);
                }
                while(markerArr.length > 0) {
                    markerArr.pop();
                }
            }

            // Initialize and add the Google map, centered on geographic center of US
            function initMap() {
                // Center on geographic center of US
                var lat = 39.8283
                var lon = -98.5795
                const pos = new google.maps.LatLng(lat, lon);
                gMap = new google.maps.Map(document.getElementById("gmap"), {
                    zoom: 4,
                    center: pos,
                })

                window.initMap = initMap;
            }

            function centerGMapOnResort(resort)
            {
                const pos = new google.maps.LatLng(resort.lat, resort.lon);
                gMap.setCenter(pos);
                gMap.setZoom(9);
            }
        </script>
    </head>
    <body>
		<div id="map"></div>
		<div id="gmap"></div>
		<script type="text/javascript">

			//Dimensions
			var margin = {top: 20, right: 20, bottom: 20, left: 20}
			var width = 960;
			var height = 500;
			var outerWidth = width + margin.left + margin.right
			var outerHeight = height + margin.top + margin.bottom

			//Define map projection
			var projection = d3.geoAlbersUsa()

			//Define path generator
			var path = d3.geoPath()
							 .projection(projection);
				 
			//Colors taken from colorbrewer2.org
           /* var quantile = d3.scaleQuantile()
                             .range(["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"])*/
			
			var quantize = d3.scaleQuantize()
                             .range(["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"])

			//Number formatting for population values
			var formatAsThousands = d3.format(",");  //e.g. converts 123456 to "123,456"

			//Create SVG element
			var svg = d3.select("#map")
						.append("g")
						.attr("id", "map")
						.attr("width", outerWidth)
						.attr("height", outerHeight)
						.append("svg")
						.attr("width", width)
						.attr("height", height)
						.attr("transform", "translate(" + margin.left + "," + margin.top + ")")

            var normalize = function(val, max, min, range=[1, 10]) {
                delta = max - min
                rangeDelta = range[1] - range[0]

                return range[0] + (val - min) * rangeDelta / delta
            }

            var normalizeArray = function(arr, range=[1, 10]) {
                var normArr = []
                // Math.max and min return NaN for some reason, so lets do it the "hard" way
                var max = 0
                var min = Number.MAX_SAFE_INTEGER
                arr.forEach(val => {
                    if(val > max)
                        max = val

                    if(val < min)
                        min = val
                })

                arr.forEach((val) => {
                    normArr.push(normalize(val, max, min, range))
                })

                return normArr
            }

            var normalizeData = function(data, range=[1, 10]) {
                vals = []
                data.forEach(d => {
                    vals.push(d['weightedRanking'])
                })

                vals = normalizeArray(vals, range)

                data.forEach((d, idx) => {
                    d['weightedRanking'] = vals[idx]
                })
            }

            var weightedRanking = function(d, params=['price', 'distance'], weights=[0.6, 0.4]) {
                total = 0
                for(const [idx, param] of params.entries()) {
                    total += d[param] * weights[idx]
                }

                // Lower total is better, so return inverse
                return 1 / total
            }

            function calculateDistance(lat1, lon1, lat2, lon2) {
                var R = 6371; // Radius of the earth in km
                var dLat = (lat2 - lat1) * Math.PI / 180;
                var dLon = (lon2 - lon1) * Math.PI / 180;
                var lat1 = lat1 * Math.PI / 180;
                var lat2 = lat2 * Math.PI / 180;

                var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) * Math.sin(dLon/2);
                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                var d = R * c;

                return d;
            }

			var determineCellIdx = function(lodging, cellSideLen, numCols, numRows) {
				loc = projection([lodging.lon, lodging.lat])
				row = Math.floor(loc[1] / cellSideLen)
				col = Math.floor(loc[0] / cellSideLen)

				return row * numCols + col
			}

            var resortName = '{{ resort }}'

            Promise.all([
                            d3.json("public/us-states.json"),
                            d3.json("/get-resort-data?resort=" + resortName),
							d3.json("public/us-cities.json")
                        ])
                    .then(function(values) {

                statesGeoData = values[0]
                resortData = values[1]
				recResort = resortData[0]
				citiesGeoData = values[2]
				// Data include U.S. territories, so filter those out as well as cities under 10k population
				citiesGeoData.features = citiesGeoData.features.filter(feature => {
					return parseInt(feature.properties.state_fips) <= 50 && feature.properties.pop_2010 > 1000
				})
				console.log(citiesGeoData)
				// Zoom in and center on the resort
				projection.scale(30000)
				var center = projection([recResort.lon, recResort.lat])
				projection.translate([width - center[0], height - center[1]])

				//Create a container in which all elements will live
				var map = svg.append("g")
							 .attr("id", "map")
							 .attr("width", width)
							 .attr("height", height)
							 .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

				var svg_legend = svg
					.append("g")
					.attr("id", "legend")
					.attr("transform", "translate(" + (outerWidth - 160) + "," + (margin.top)+ ")");

                Promise.all([d3.json('/gethotel?lat=' + recResort.lat + '&lon=' + recResort.lon + '&limit=100')]).then(function(resortRequestData) {

					lodgingData = resortRequestData[0]
                    lodgingData.forEach(lodging => {
                        distance = calculateDistance(recResort.lat, recResort.lon, lodging.lat, lodging.lon)
                        lodging['distance'] = distance
                        ranking = weightedRanking(lodging)
                        lodging['weightedRanking'] = ranking
                    })
                    normalizeData(lodgingData)

                    map.selectAll("path")
                        .data(statesGeoData.features)
                        .enter()
                        .append("path")
                        .attr("d", path)
                        .style("fill", function(d) {
                                return "#ddd";
                        })
                        .style('stroke-width', 0.1)
                        .style('stroke', 'black')
                        .on('mouseover', function(d) {
                                d3.select(this).style('stroke-width', 1)
                        })
                        .on('mouseout', function(d) {
                                d3.select(this).style('stroke-width', 0.1)
                        })

					map.selectAll("circle .city")
                       .data(citiesGeoData.features)
                       .enter()
                       .append("circle")
                       .attr('class', 'city')
                       .attr("cx", function(d) {
							//console.log(d)
                            return projection([
								d.geometry.coordinates[0],
								d.geometry.coordinates[1]])[0];
                       })
                       .attr("cy", function(d) {
							return projection([
								d.geometry.coordinates[0],
								d.geometry.coordinates[1]])[1];
                       })
                       .attr("r", function(d) {
                            return 1.5;
                       })
                       .style("fill", "black")
                       .style("stroke", "black")
                       .style("stroke-width", 0.25)
                       .style("opacity", 0.75)
                       .on('mouseover', function(d) {
                            d3.select(this).style('stroke-width', 1)
                                           .style('stroke', 'black')
                       })
                       .on('mouseout', function(d) {
                            d3.select(this).style('stroke-width', 0.25)
                                           .style('stroke', 'gray')
                       })
					
					map.selectAll("text .city")
					   .data(citiesGeoData.features)
					   .enter()
                       .append("text")
					   .attr("class", "city")
					   .attr('x', function(d) {
							return projection([
								d.geometry.coordinates[0],
								d.geometry.coordinates[1]])[0] + 5})
					   .attr('y', function(d) {
							return projection([
								d.geometry.coordinates[0],
								d.geometry.coordinates[1]])[1]})
                       .text(function(d) {
                            return d.properties.name;
                       })
					   .style("font-size", 10)

					// Calculate grid dimensions
					var gridData = []
					const cellSideLen = 20
					const numCols = width / cellSideLen
					const numRows = height / cellSideLen

					for(let row = 0; row < numRows; row++) {
						for(let col = 0; col < numCols; col++) {
							cell = {
								x: col * cellSideLen,
								y: row * cellSideLen,
								w: cellSideLen,
								h: cellSideLen,
								lodgings: []
							}
							gridData.push(cell)
						}
					}

					// Add the hotels to the appropriate cell to prepare gradient
					lodgingData.forEach(lodging => {
						cellIdx = determineCellIdx(lodging, cellSideLen, numCols, numRows)
						gridData[cellIdx].lodgings.push(lodging)
					})
					
					var getRankingAvg = function(d) {
						if(d.lodgings.length == 0)
							return 0

						var sum = 0
						d.lodgings.forEach(lodging => {
							sum += lodging['weightedRanking']
						})

						var avg = sum / d.lodgings.length
						
						return avg
					}

					quantize.domain([
						d3.min(gridData, d => getRankingAvg(d)), 
						d3.max(gridData, d => getRankingAvg(d))
					]);
					//Create a rect for the grid
					var grid = map
						.append("svg")
						.attr('x', 0)
						.attr('y', 0)
						.attr("width", width)
						.attr("height", height)
						.append("g");

					grid.selectAll("rect .cell")
					    .data(gridData)
						.enter()
						.append('rect')
						.attr('class', 'cell')
						.attr('x', function(d) {
							return d.x
						})
						.attr('y', function(d) {
							return d.y
						})
						.attr('width', function(d) {
							return d.w
						})
						.attr('height', function(d) {
							return d.h
						})
						.style('fill', function(d) {
							var avg = getRankingAvg(d)
							if(avg == 0)
								return 'None'
							
							
							return quantize(avg)
						})
						//.style('stroke', 'black')
						//.style('stroke-opacity', 0.1)
						.style('opacity', 0.75)

					map.selectAll("circle .resort")
                       .data(resortData)
                       .enter()
                       .append("circle")
					   .attr('class', 'resort')
                       .attr("cx", function(d) {
                            return projection([d.lon, d.lat])[0];
                       })
                       .attr("cy", function(d) {
                            return projection([d.lon, d.lat])[1];
                       })
                       .attr("r", 5)
                       .style("fill", "yellow")
                       .style("stroke", "gray")
                       .style("stroke-width", 0.25)
                       .style("opacity", 0.75)
                       .on('mouseover', function(d) {
                            d3.select(this).style('stroke-width', 1)
                                           .style('stroke', 'black')
                       })
                       .on('mouseout', function(d) {
                            d3.select(this).style('stroke-width', 0.25)
                                           .style('stroke', 'gray')
                       })
                       .append("title")			//Simple tooltip
                       .text(function(d) {
                            return d.resort_name;
                       });
					
					var tip = d3.tip()
						.attr("class", 'd3-tip')
						.attr("id", "tooltip")
						.offset(function() {
							//var m = d3.mouse(this)[0]
							//console.log(m[0])
							
							return [0, 0]
						})
						.html(function(d) {
							return "<text>" + 
									"Name: " + d.name + "</br>" +
									"Price: $" + d.price + "</br>" +
									"Our Rating: " + d.weightedRanking + "</br>" +
									"Address: " + d.address + "</br>" +
									"</text>"
						})
						.style("line-height", 1)
						.style("font-size", "70%")
						.style("padding", "5px")
						.style("background", "rgba(0, 0, 0, 0.8)")
						.style("color", "#fff")
						.style("border-radius", "2px")

					map.selectAll("circle .hotel")
                       .data(lodgingData)
                       .enter()
                       .append("circle")
                       .attr('class', 'hotel')
                       .attr("cx", function(d) {
                            return projection([d.lon, d.lat])[0];
                       })
                       .attr("cy", function(d) {
                            return projection([d.lon, d.lat])[1];
                       })
                       .attr("r", function(d) {
                            return 3;
                       })
                       .style("fill", "green")
                       .style("stroke", "gray")
                       .style("stroke-width", 0.25)
                       .style("opacity", 0.75)
                       .on('mouseover', function(d) {
                            d3.select(this).style('stroke-width', 1)
                                           .style('stroke', 'black')
							tip.show(d)
                       })
                       .on('mouseout', function(d) {
                            d3.select(this).style('stroke-width', 0.25)
                                           .style('stroke', 'gray')
							tip.hide()
                       })
					
					map.call(tip)
					var legend = d3.legendColor()
						.labelFormat(d3.format(".2f"))
						.useClass(false)
						.titleWidth(100)
						.scale(quantize);
					svg_legend.call(legend)

					addGMapMarker(new google.maps.LatLng(recResort.lat, recResort.lon), resortMarkers, "green")
					addAllGmapMarkers(lodgingData, lodgingMarkers)
					centerGMapOnResort(recResort)

                })
            })
		</script>
        <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAsIkSW_j4Ml6Cy_xx5vqepARjEaul4SSM&callback=initMap"></script>
	</body>
</html>